<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
		body {
			background: #ccc;
			font-family: sans-serif;
		}
		body, html, #canvas, #output {
			margin: 0;
			width: 100%;
			height: 100%;
		}
		#canvas {
			position: absolute;
			top: 0px;
			left: 0px;
			border: 0;
			overflow: hidden;
			display: block;
		}
		#output {
			padding: 10px;
			overflow: hidden scroll;
			box-sizing: border-box;
		}
		#output .line {
			border-left: 5px solid;
			padding-left: 10px;
		}
		</style>
	</head>
	<body>
		<div id="output"></div>
		<canvas id="canvas">Canvas not supported.</canvas>
		<script>
			var output = document.getElementById('output');
			function appendOutput(message, bold, textColor, borderColor) {
				const span = document.createElement("span");
				span.textContent = message;
				span.className = "line";
				if (textColor) {
					span.style.color = textColor;
				}
				if (borderColor) {
					span.style.borderColor = borderColor;
				}
				if (bold) {
					span.style.fontWeight = "bold";
				}
				output.appendChild(span);
				output.appendChild(document.createElement("br"));
				output.scrollTop = output.scrollHeight;
			}
			function parseAnsiColorRgb(line) {
				// Only handles RGB format because our logging system only uses that.
				const match = line.match(/^\x1b\[38;2;(\d+);(\d+);(\d+)m([\s\S]*?)\x1b\[0m$/);
				if (!match) {
					return { color: "black", message: line };
				}
				const [, r, g, b, message] = match;
				return { color: `rgb(${r}, ${g}, ${b})`, message: message };
			}
			var Module = {
				print: function(text) {
					const parsedLine = parseAnsiColorRgb(text);
					console.log(parsedLine.message);
					appendOutput(parsedLine.message, false, undefined, parsedLine.color);
				},
				printErr: function(text) {
					console.error(text);
					appendOutput(text, false, "red");
				},
				onExit: function() {
					// After client quits, hide the canvas and reset the cursor, as the canvas
					// will be entirely black, also blocking the view of the console output.
					Module['canvas'].style.display = "none";
					// Make sure to reset cursor because it sometimes does not become visible.
					Module['canvas'].style.cursor = "default";
					appendOutput("Client closed. Reload the page to restart.", true);
					const restartButton = document.createElement("button");
					restartButton.textContent = "Reload page";
					restartButton.style.marginTop = "10px";
					restartButton.style.padding = "5px";
					restartButton.addEventListener('click', e => location.reload());
					output.appendChild(restartButton);
					output.scrollTop = output.scrollHeight;
				},
				canvas: document.getElementById('canvas')
			};
			window.onerror = function(text) {
				appendOutput(text, true, "red");
			};
			Module['canvas'].addEventListener('contextmenu', e => e.preventDefault());
			Module['canvas'].addEventListener('webglcontextcreationerror', e => {
				appendOutput(`Failed to create WebGL context: ${e.statusMessage || "Unknown error"}`, true, "red");
			});
			Module['canvas'].addEventListener('webglcontextlost', e => {
				// The client cannot currently recover from GL context loss, because it
				// would require reloading all textures, framebuffers etc.
				appendOutput(`The WebGL context was lost: ${e.statusMessage || "Unknown error"}`, true, "red");
				Module.ccall('EmscriptenCallbackQuit', null, [], []);
			});
			Module['canvas'].addEventListener('dragover', e => {
				e.preventDefault();
				e.dataTransfer.dropEffect = "none";
				if (!e.dataTransfer.items) {
					return;
				}
				for (const item of e.dataTransfer.items) {
					if (item.kind == 'file' || item.kind == 'string') {
						e.dataTransfer.dropEffect = "copy";
						return;
					}
				}
			});
			Module['canvas'].addEventListener('drop', async e => {
				e.preventDefault();
				if (!e.dataTransfer.items) {
					return;
				}
				var dropFile = null;
				var dropPath = null;
				var dropLink = null;
				for (const item of e.dataTransfer.items) {
					if (item.kind == 'file') {
						const file = item.getAsFile();
						const isDemo = file.name.endsWith(".demo");
						const isMap = file.name.endsWith(".map");
						const homePath = "/home/web_user/.local/share/ddnet"
						var path;
						if (isDemo) {
							path = `${homePath}/demos`
						} else if (isMap) {
							path = `${homePath}/maps`
						} else {
							continue;
						}
						if (dropLink != null) {
							alert("You cannot drop files and links at the same time.");
							break;
						}
						if (dropFile != null) {
							alert("You cannot open multiple files at the same time. Only the first file will be opened.");
							break;
						}
						dropFile = file;
						dropPath = path;
					} else if (item.kind == 'string') {
						const string = e.dataTransfer.getData(item.type);
						if (string.startsWith('ddnet://')) {
							if (dropFile != null) {
								alert("You cannot drop files and links at the same time.");
								break;
							}
							if (dropLink != null && dropLink != string) {
								alert("You cannot connect to multiple URLs at the same time. You will be connected to the first URL.");
								break;
							}
							dropLink = string;
						}
					}
				}
				if (dropFile != null) {
					const buffer = await dropFile.arrayBuffer();
					const data = new Uint8Array(buffer);
					FS.createPath(dropPath, "upload", true, true);
					FS.writeFile(`${dropPath}/upload/${dropFile.name}`, data);
					Module.ccall('EmscriptenCallbackDropFile', null, ['string'], [`${dropPath}/upload/${dropFile.name}`]);
				} else if (dropLink != null) {
					Module.ccall('EmscriptenCallbackDropFile', null, ['string'], [dropLink]);
				} else {
					alert("The items you dropped are not supported. You can drop .demo and .map files, as well as ddnet:// links.");
				}
			});
		</script>
		<script src="DDNet.js"></script>
	</body>
</html> 
